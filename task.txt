1. Нужно собирать данные (гр/мин/сек). Они будут лежать следующим образом: несколько object (вроде dict) в списке (list) всё это в JSON
Надо будет пробежаться по всему списку по каждому словарику и выдернуть значение по первым трём ключам
    Раскладывание в десятичный градус get_decimal_angle
    Складывание обратно get_dms_angle

2. Посчитать практическую сумму измеренных углов is/IS/measured и теоретическую сумму углов для полигона should_be/theoretical_angle (зависит от углов в полигоне).
    Подсчёт суммы измеренных углов get_sum_of_measured_angles
    Подсчёт теоретической суммы углов calc_sum_of_theoretical_angles надо передавать в функцию len(site) длину полученного массива. В массиве каждый элемент - угол, значит длина массива - количество углов

3. Посчитать расхождение difference_ang, потом это расхождение надо поделить на количество углов, что б невязку ровно раскидать по всем углам. Можно ещё разложить десятичный угол в d/m/s, что б понимать, сколько секунд надо раскидать. 
Есть такая огромная вероятность, что ровно по 1 секунде почти никогда не получится раскидывать.... (А вообще, когда измерения Т30 делают... то как в таких ситуациях раскидывать невязку? -_-) - поэтому надо будет брать и раскидывать поправку целочисленным делением, отнимая от вычисленной невязки поправку до тех пор, пока невязка не закончится
    Подсчёт невязки calc_difference_ang. Надо передавать полученные вычисления измеренных углов и теоретических

4. Надо как у Алины посчитать в отдельной ячейке поправку, что б её хранить в переменной и просто раскидывать в углы
    calc_amendments Есть вопрос в том, можно ли будет ровно столько раскидывать и будут ли углы на самом деле хоть как-то меняться. Типа вдруг поправка будет пол секнды в кажды угол, ну куда это и как раскидывать тогда? надо потестить на различных задачах

5. Посчиать допустимую невязку
Она зависит от количества углов в ходе и от точности используемог оприбора. По дефолту прописал 1 минуту, поэтому внутри прописал позиционный аргумент с 1 минутой, типа в Унике обычно Т30 будет, поэтому я в возврате разделил на 60, что б получил именно величину в минутах.
    calc_permissible_discrepancy Можно поменять и под другие приборы и величины точностей, но для этого надо будет придумать третий параметр, в котором надо будет указывать, в какой величине передаётся "двойная точность прибора". Либо всегда передавать в секундах, всё равно больше 60 секунд не придётся писать, скорее всего. Надо будет ЗАТЕСТИТЬ!
    check_difference Проверка на то, в допуске ли полученная невязка или нет, если нет, то надо будет ошибку как-то генерить.... хз как это придумать, в обработке ошибок как-нибудь провернуть, и возвращать тогда ответ какой-то типа "Ошибка" либо как-то в API есть внутренний триггер на это

6. Пройтись циклом по переданным углам, собрать необходимые данные (только углы).
Посчитать сумму измеренных углов, теоретическую сумму углов, невязку, допуск невязки, попраку на каждый угол (это просто что б проще было уравнивать, что б поправка хранилась в отдельно "ячейке" переменной)

7. Внести поправки в углы... Удобнее это делать с десятичными величинами.
Собранные углы перевести все в десятичные величины, поправку тоже в десятичной величине высчитывать, и просто прибавить/отнять к каждому углу
Есть такой вопросик. Что возможно слишком мелкую поправку какую-то и не надо будет раскидывать в каждый угол, т.к. это будет бесполезно. Надо будет этот момент как-нибудь попробовать обработать. Например целочисленным делением на количество углов и просто отнимать это число, если оно больше 0.1', тут есть цитата с сайта одного "Когда полученная невязка не превышает допустимую, то ее разбрасывают с обратным знаком на все измеренные углы, не дробя при этом менее чем на 0,1'. Вносим поправки по -0,1’ в каждый измеренный угол." Типа дробить меньше, чем на 6" не имеет смысла.
    ПОООЭЭЭТОМУ, возможно надо придумать какую-то схему. Что я передам те же углы, что были получены + все вычисленные снизу темы, там будет поле с невязкой. Придумать функционал, что б пользователь сам вручную раскидывал поправки в нужные ему места и динамически изменялось поле с поправкой, что б больше или меньше нельзя было раскинуть. Как раскинет и условия соберутся, если сумма исправленных углов будет равна теоретической И истратится всяк невязка (должна быть кнопка на проверку этих условий), тогда появится кнопка на дальнейшие расчёты.

8. Вернуть JSON список словариков, где будут ключи CorDeg, CorMin, CorSec, а значениями исправленные углы в d/m/s

ВСЕ ПУНКТЫ до 8 работают. Возвращаются нормальные данные и раскидываются по полям✔️

НАШЁЛ ОШИБКУ. на Ванином первом примере. там где левые по ходу движения углы измерялись... Там теряется 5 секунд со всего полигона, когда делаешь сумму исправленных углов... 11 точек и 5 секунд. Я хз, что с этим делать. Вероятнее всего это из-за того, что округлял изначально исправленные углы, что б передать на формочку, а потом из этих же углов (d/m/s) я считал сумму углов. Также если смотреть по Ваниным числам, которые он получил через свою формулу, то тоже теряется 5"
Я сделал новую функцию для вывода информации о сумме исправленных углов calc_sum_of_corrected_angles. Возможно надо будет ещё использовать и дальше везде, пока для теста данных от Вани, работаю с ней и использую get_correct_angles1. Т.к. внутри этой функции идёт обработка измеренных левых углов по ходу движения. 
Возможно надо будет на формочку добавить флаг для уточнения этой информации. Хотя это довольно редкая тема. Надо подумать. Что б вместе с измеренными углами отсылалась инфа о том, какие углы измерялись и сразу использовалась необходимая функция для вычисления измерений


9. Надо получать дирекционные углы, которые указал пользователь. После чего просчитать столбец с дир. углами. Только как их просчитывать О_о. Надо в отдельный список класть или делать так же как с дистанцией? 
Есть дилемма на счёт того, что если в первой строке будет указываться ихсодный угол, в котором будут отсуствовать данные об угле/расстоянии и т.п. НО ОН нужен для вычислений дальнейших. То тогда надо работать с углами, начиная от 1го индекса массива... Но тогда и когда возвращаю, для использования на фронте тоже надо будет их раскидывать относительно какого-то другого индекса.     Рис. 1

10. После чего рассчитать все дирекционные углы и вернуть вместе с исправленными. 
Пользователь вводит один угол, походу, самый начальный, ну и пройдя по всему полигону, вычисления должны привести к тому же результату ЭТО НАДО БУДЕТ ПРОВЕРЯТЬ
Видимо, надо будет как раз записывать их также как и расстояние между пунктами. Записываться будет в словарь предыдущей точки по ходу движения.
Считаю дир. углы и возвращаю их на свои места, они записываются на фронте в строку предыдущего пункта (Это значит, что этот дир угол между пунктом в котором он находится и следующим.)✔️

11. Отдельно так же как невязки и практику с теорией просчитать сумму длин сторон хода✔️

DataInput2.json для того, что б с этими исходными данными просчитать приращение координат сначала и приступать к вычислению коориднат уже...✔️ эти входные данные подходят для проверки, ничего нового не добавлялось

12. Создал DataInput3.json там появился новый объект startCoords, там передаются координаты первой написанной точки. Пока это 95 точка (На Ванином примере) Потом надо будет как-то это переделывать. 
Т.к. эта координата будет передаваться отдельно, походу
Либо создать список объектов coords, первая координата, которая там написана будет исходной, просто взять её за стартовую ну и потом дополнить этот список и вернуть его обратно. (Просто у меня всегда дилемма. Нужно ли возвращать те данные, которые были переданы на бэк. По уму стоит это делать)

➡️ НАЧИНАЮ ОТСЮДА ТЕСТЫ, что б сразу с интересными входными данными. Создал DataInput3 copy.json Попробую сначала так. как написал в строке выше. Перед передачей просто буду формировать такой же список координат и просто передавать их, включая первоначальную координату, которая пришла с фронта.
⚠️ Преобразовал рабочую функцию в get_result, там на входе ожидаю простой словарь и уже потом буду внутри парсить и использовать необходимые словари/списки внутри. А не так как было до этого, что я передавал уже необходимые объекты в программу. Буду просто брать словарь и через метод get тягать необходимые объекты из словаря и работать с ними, щас сначала это тестиирую


⚠️⚠️⚠️⚠️⚠️Смог считать приращения координат, исправленные приращения координат и всё-всё. Но есть неувязочка, что не сходится с тем, что в экселе из-за моих округлений (всего и вся). Сейчас пробую переписывать эту функцию пошагово со сравнением каждых получаемых результатов, что б не было несхождений, прям вот подгоню всё и вся. Округления буду использовать только для отображения на фронте, например.


ДОПОЛНЕНИЯ
С исходными данными надо придумать какой-то шаблон. Надо передавать значение left, right в двух переменных. Одна переменная будет отвечать за то, ход измерялся по часовой стрелке или против часовой стрелке и какие углы по ходу измерялись. Потом под капотом надо брать и пересчитывать переменные эти, т.к. в каждой ситуации надо будет разные значения подставлять в мои формацлы. Т.к., если ход имзерялся по часовой стрелке, а углы были левые, то значит для теоретической суммы горизонтальных углов надо использовать формулу для внешних углов фигуры, там n+2, так же будет, если ход измерялся против часовой стрелки, а углы измерялись правые и соответственно так в обратную сторону работает
Добавил в модельку direction_of_circling: str = 'right' и side_of_angles: str = 'right'


ИДЕИ
    ФРОНТ:
Что б добавить строчку без всяких бубнов, куда можно было бы записать только дир. угол, а с остальных собирать всю инфу, то потом можно добавлять обычную стрчоку, но собирать данные для отправки на расчёты только начиная с 1го индекса. И так же с последним. то бишь цикл for(i=1, i++, len(array)-1), типа такого. Также можно начальную и конечную координату тоже писать в первую и последнюю строчку и собирать для передачи на бэк, а потом вычислять всё. Внутри скрипта я это арспарсю в нужном виде, а потом соберу список полностью всех координат [Начальная, промежуточные, конечная] через append and pop могу это сделать

    БЭК:
В конце нужна будет кнопочка, которая будет передавать прям ВСЕ данные, что б их можно было запихнуть в csv/excel, что б можно было распечатать, там тоже по всем необходимым полям раскидать значения и всё. Форматирование можно будет один раз сделать для примера и просто переносить форматирование из одно файла и всё (и потом отсылать в ТГ бот:D)

add /TestData/{id} (add second initial data), clear endpoints, changed class Points (add bearingAngle) add calc distance, changed calc sum_corrected_angles -> sum_cor (modify)


ПРОВЕРИТЬ
Для проверки на сходимость, последний дир. угол, который будет в таблице, должен будет равняться переданному дир.углу. ДОБАВИТЬ

⚠️НА ВСЕ ВОЗМОЖНЫЕ ПРОБЛЕМЫ НАДО навесить обработчик ошибок. Например, если каких-то данных не хватает, то надо возвращать информативную ошибку. По поводу этого можно попробовать посмотреть в видосах, как обрабатывают ошибки в FastAPI.
На вход обязательно должно податься начальный дир. угол + начальные и конечные координаты