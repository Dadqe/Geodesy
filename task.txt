1. Нужно собирать данные (гр/мин/сек). Они будут лежать следующим образом: несколько object (вроде dict) в списке (list) всё это в JSON
Надо будет пробежаться по всему списку по каждому словарику и выдернуть значение по первым трём ключам
    Раскладывание в десятичный градус get_decimal_angle
    Складывание обратно get_dms_angle

2. Посчитать практическую сумму измеренных углов is/IS/measured и теоретическую сумму углов для полигона should_be/theoretical_angle (зависит от углов в полигоне).
    Подсчёт суммы измеренных углов get_sum_of_measured_angles
    Подсчёт теоретической суммы углов calc_sum_of_theoretical_angles надо передавать в функцию len(site) длину полученного массива. В массиве каждый элемент - угол, значит длина массива - количество углов

3. Посчитать расхождение difference_ang, потом это расхождение надо поделить на количество углов, что б невязку ровно раскидать по всем углам. Можно ещё разложить десятичный угол в d/m/s, что б понимать, сколько секунд надо раскидать. 
Есть такая огромная вероятность, что ровно по 1 секунде почти никогда не получится раскидывать.... (А вообще, когда измерения Т30 делают... то как в таких ситуациях раскидывать невязку? -_-) - поэтому надо будет брать и раскидывать поправку целочисленным делением, отнимая от вычисленной невязки поправку до тех пор, пока невязка не закончится
    Подсчёт невязки calc_difference_ang. Надо передавать полученные вычисления измеренных углов и теоретических

4. Надо как у Алины посчитать в отдельной ячейке поправку, что б её хранить в переменной и просто раскидывать в углы
    calc_amendments Есть вопрос в том, можно ли будет ровно столько раскидывать и будут ли углы на самом деле хоть как-то меняться. Типа вдруг поправка будет пол секнды в кажды угол, ну куда это и как раскидывать тогда? надо потестить на различных задачах

5. Посчиать допустимую невязку
Она зависит от количества углов в ходе и от точности используемог оприбора. По дефолту прописал 1 минуту, поэтому внутри прописал позиционный аргумент с 1 минутой, типа в Унике обычно Т30 будет, поэтому я в возврате разделил на 60, что б получил именно величину в минутах.
    calc_permissible_discrepancy Можно поменять и под другие приборы и величины точностей, но для этого надо будет придумать третий параметр, в котором надо будет указывать, в какой величине передаётся "двойная точность прибора". Либо всегда передавать в секундах, всё равно больше 60 секунд не придётся писать, скорее всего. Надо будет ЗАТЕСТИТЬ!
    check_difference Проверка на то, в допуске ли полученная невязка или нет, если нет, то надо будет ошибку как-то генерить.... хз как это придумать, в обработке ошибок как-нибудь провернуть, и возвращать тогда ответ какой-то типа "Ошибка" либо как-то в API есть внутренний триггер на это

6. Пройтись циклом по переданным углам, собрать необходимые данные (только углы).
Посчитать сумму измеренных углов, теоретическую сумму углов, невязку, допуск невязки, попраку на каждый угол (это просто что б проще было уравнивать, что б поправка хранилась в отдельно "ячейке" переменной)

7. Внести поправки в углы... Удобнее это делать с десятичными величинами.
Собранные углы перевести все в десятичные величины, поправку тоже в десятичной величине высчитывать, и просто прибавить/отнять к каждому углу
Есть такой вопросик. Что возможно слишком мелкую поправку какую-то и не надо будет раскидывать в каждый угол, т.к. это будет бесполезно. Надо будет этот момент как-нибудь попробовать обработать. Например целочисленным делением на количество углов и просто отнимать это число, если оно больше 0.1', тут есть цитата с сайта одного "Когда полученная невязка не превышает допустимую, то ее разбрасывают с обратным знаком на все измеренные углы, не дробя при этом менее чем на 0,1'. Вносим поправки по -0,1’ в каждый измеренный угол." Типа дробить меньше, чем на 6" не имеет смысла.
    ПОООЭЭЭТОМУ, возможно надо придумать какую-то схему. Что я передам те же углы, что были получены + все вычисленные снизу темы, там будет поле с невязкой. Придумать функционал, что б пользователь сам вручную раскидывал поправки в нужные ему места и динамически изменялось поле с поправкой, что б больше или меньше нельзя было раскинуть. Как раскинет и условия соберутся, если сумма исправленных углов будет равна теоретической И истратится всяк невязка (должна быть кнопка на проверку этих условий), тогда появится кнопка на дальнейшие расчёты.

8. Вернуть JSON список словариков, где будут ключи CorDeg, CorMin, CorSec, а значениями исправленные углы в d/m/s

ВСЕ ПУНКТЫ до 8 работают. Возвращаются нормальные данные и раскидываются по полям

НАШЁЛ ОШИБКУ. на Ванином первом примере. там где левые по ходу движения углы измерялись... Там теряется 5 секунд со всего полигона, когда делаешь сумму исправленных углов... 11 точек и 5 секунд. Я хз, что с этим делать. Вероятнее всего это из-за того, что округлял изначально исправленные углы, что б передать на формочку, а потом из этих же углов (d/m/s) я считал сумму углов. Также если смотреть по Ваниным числам, которые он получил через свою формулу, то тоже теряется 5"
Я сделал новую функцию для вывода информации о сумме исправленных углов calc_sum_of_corrected_angles. Возможно надо будет ещё использовать и дальше везде, пока для теста данных от Вани, работаю с ней и использую get_correct_angles1. Т.к. внутри этой функции идёт обработка измеренных левых углов по ходу движения. 
Возможно надо будет на формочку добавить флаг для уточнения этой информации. Хотя это довольно редкая тема. Надо подумать. Что б вместе с измеренными углами отсылалась инфа о том, какие углы измерялись и сразу использовалась необходимая функция для вычисления измерений


9. Надо получать дирекционные углы, которые указал пользователь. После чего просчитать столбец с дир. углами. Только как их просчитывать О_о. Надо в отдельный список класть или делать так же как с дистанцией? 
Есть дилемма на счёт того, что если в первой строке будет указываться ихсодный угол, в котором будут отсуствовать данные об угле/расстоянии и т.п. НО ОН нужен для вычислений дальнейших. То тогда надо работать с углами, начиная от 1го индекса массива... Но тогда и когда возвращаю, для использования на фронте тоже надо будет их раскидывать относительно какого-то другого индекса.     Рис. 1

10. После чего рассчитать все дирекционные углы и вернуть вместе с исправленными. 
Пользователь вводит один угол, походу, самый начальный, ну и пройдя по всему полигону, вычисления должны привести к тому же результату ЭТО НАДО БУДЕТ ПРОВЕРЯТЬ
Видимо, надо будет как раз записывать их также как и расстояние между пунктами. Записываться будет в словарь предыдущей точки по ходу движения.

11. Отдельно так же как невязки и практику с теорией просчитать сумму длин сторон хода

12. Относительно этого просчитать приращения координат... Надо подумать, куда кидать эти вычисления

В конце нужна будет кнопочка, которяа будет передавать прям ВСЕ данные, что б их можно было запи-ххнуть в csv/excel, что б можно было распечатать, там тоже по всем необходимым полям раскидать значения и всё. Форматирование можно будет один раз сделать для примера и просто переносить форматирование из одно файла и всё



add /TestData/{id} (add second initial data), clear endpoints, changed class Points (add bearingAngle) add calc distance, changed calc sum_corrected_angles -> sum_cor (modify)